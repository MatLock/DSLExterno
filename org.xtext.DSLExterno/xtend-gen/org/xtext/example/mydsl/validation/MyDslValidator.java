/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.xtext.example.mydsl.myDsl.Asignacion;
import org.xtext.example.mydsl.myDsl.Aula;
import org.xtext.example.mydsl.myDsl.Curso;
import org.xtext.example.mydsl.myDsl.Dedicacion;
import org.xtext.example.mydsl.myDsl.Horario;
import org.xtext.example.mydsl.myDsl.Materia;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Planificacion;
import org.xtext.example.mydsl.myDsl.Profesor;
import org.xtext.example.mydsl.myDsl.Recursos;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  @Check
  public void dedicacion(final Planificacion p) {
    final EList<Curso> cursos = p.getCursos();
    final Procedure1<Curso> _function = new Procedure1<Curso>() {
      public void apply(final Curso c) {
        MyDslValidator.this.checkDedicacion(c);
      }
    };
    IterableExtensions.<Curso>forEach(cursos, _function);
  }
  
  public void checkDedicacion(final Curso curso) {
    final Profesor profesor = curso.getDictadaPor();
    EObject _eContainer = curso.eContainer();
    final Planificacion planificacion = ((Planificacion) _eContainer);
    final EList<Curso> cursos = planificacion.getCursos();
    int _cantidadDeVeces = this.cantidadDeVeces(profesor, cursos);
    int _cantidadDeMateriasPorDedicacion = this.cantidadDeMateriasPorDedicacion(profesor);
    boolean _greaterThan = (_cantidadDeVeces > _cantidadDeMateriasPorDedicacion);
    if (_greaterThan) {
      String _name = profesor.getName();
      String _plus = ("El Profesor: " + _name);
      String _plus_1 = (_plus + " tiene asignadas mas materias de las que puede dictar");
      this.error(_plus_1, profesor, MyDslPackage.Literals.PROFESOR__DEDICACION);
    }
  }
  
  private int cantidadDeVeces(final Profesor profesor, final Iterable<Curso> cursos) {
    final Function1<Curso, Boolean> _function = new Function1<Curso, Boolean>() {
      public Boolean apply(final Curso it) {
        Profesor _dictadaPor = it.getDictadaPor();
        return Boolean.valueOf(_dictadaPor.equals(profesor));
      }
    };
    Iterable<Curso> _filter = IterableExtensions.<Curso>filter(cursos, _function);
    return IterableExtensions.size(_filter);
  }
  
  private int cantidadDeMateriasPorDedicacion(final Profesor p) {
    Dedicacion _dedicacion = p.getDedicacion();
    if (_dedicacion != null) {
      switch (_dedicacion) {
        case SIMPLE:
          return 1;
        case SEMI:
          return 2;
        case EXCLUSIVA:
          return 5;
        default:
          String _name = p.getName();
          String _plus = ("El profesor: " + _name);
          String _plus_1 = (_plus + " no tiene una dedicacion asignada");
          throw new RuntimeException(_plus_1);
      }
    } else {
      String _name = p.getName();
      String _plus = ("El profesor: " + _name);
      String _plus_1 = (_plus + " no tiene una dedicacion asignada");
      throw new RuntimeException(_plus_1);
    }
  }
  
  @Check
  public void checkMateriasAsignadas(final Planificacion p) {
    EList<Curso> _cursos = p.getCursos();
    final List<Materia> materias = this.materias(_cursos);
    final EList<Asignacion> asignaciones = p.getAsignaciones();
    final Function1<Materia, Boolean> _function = new Function1<Materia, Boolean>() {
      public Boolean apply(final Materia materia) {
        return Boolean.valueOf(MyDslValidator.this.perteneceAAlgunaAsignacion(materia, asignaciones));
      }
    };
    final boolean expresionBooleana = IterableExtensions.<Materia>forall(materias, _function);
    if ((!expresionBooleana)) {
      this.error("Hay materias sin asignar", p, MyDslPackage.Literals.PLANIFICACION__CURSOS);
    }
  }
  
  private List<Materia> materias(final EList<Curso> cursos) {
    final Function1<Curso, Materia> _function = new Function1<Curso, Materia>() {
      public Materia apply(final Curso it) {
        return it.getMateria();
      }
    };
    return ListExtensions.<Curso, Materia>map(cursos, _function);
  }
  
  private boolean perteneceAAlgunaAsignacion(final Materia materia, final EList<Asignacion> asignaciones) {
    final Function1<Asignacion, Boolean> _function = new Function1<Asignacion, Boolean>() {
      public Boolean apply(final Asignacion it) {
        return Boolean.valueOf(MyDslValidator.this.tieneMateria(it, materia));
      }
    };
    return IterableExtensions.<Asignacion>exists(asignaciones, _function);
  }
  
  private boolean tieneMateria(final Asignacion a, final Materia materia) {
    EList<Horario> _horarios = a.getHorarios();
    final Function1<Horario, Boolean> _function = new Function1<Horario, Boolean>() {
      public Boolean apply(final Horario h) {
        Materia _materia = h.getMateria();
        return Boolean.valueOf(Objects.equal(_materia, materia));
      }
    };
    return IterableExtensions.<Horario>exists(_horarios, _function);
  }
  
  @Check
  public void checkCargaHorariaDeMateria(final Planificacion p) {
    EList<Curso> _cursos = p.getCursos();
    final List<Materia> materias = this.materias(_cursos);
    final Procedure1<Materia> _function = new Procedure1<Materia>() {
      public void apply(final Materia materia) {
        MyDslValidator.this.chequearHorarios(materia, p);
      }
    };
    IterableExtensions.<Materia>forEach(materias, _function);
  }
  
  private void chequearHorarios(final Materia materia, final Planificacion p) {
    final Iterable<Asignacion> asignacionesDeMateria = this.asignaciones(materia, p);
    Integer cargaHorariaDeMateria = this.obtenerCargaDeMateria(asignacionesDeMateria, materia);
    int cantidadDeDiasDeMateria = IterableExtensions.size(asignacionesDeMateria);
    boolean _and = false;
    int _cargaHoraria = materia.getCargaHoraria();
    boolean _equals = ((cargaHorariaDeMateria).intValue() == _cargaHoraria);
    if (!_equals) {
      _and = false;
    } else {
      int _cantidadDeDias = materia.getCantidadDeDias();
      boolean _equals_1 = (cantidadDeDiasDeMateria == _cantidadDeDias);
      _and = _equals_1;
    }
    boolean _not = (!_and);
    if (_not) {
      String _name = materia.getName();
      String _plus = ("La materia: " + _name);
      String _plus_1 = (_plus + " No cumple con la carga horaria o con la cantidad De Dias ");
      this.error(_plus_1, p, MyDslPackage.Literals.PLANIFICACION__ANIO);
    }
  }
  
  private Iterable<Asignacion> asignaciones(final Materia m, final Planificacion p) {
    EList<Asignacion> _asignaciones = p.getAsignaciones();
    final Function1<Asignacion, Boolean> _function = new Function1<Asignacion, Boolean>() {
      public Boolean apply(final Asignacion asignacion) {
        return Boolean.valueOf(MyDslValidator.this.contieneAMateria(asignacion, m));
      }
    };
    return IterableExtensions.<Asignacion>filter(_asignaciones, _function);
  }
  
  private Integer obtenerCargaDeMateria(final Iterable<Asignacion> asignaciones, final Materia m) {
    Integer _xblockexpression = null;
    {
      final Function1<Asignacion, EList<Horario>> _function = new Function1<Asignacion, EList<Horario>>() {
        public EList<Horario> apply(final Asignacion it) {
          return it.getHorarios();
        }
      };
      Iterable<EList<Horario>> _map = IterableExtensions.<Asignacion, EList<Horario>>map(asignaciones, _function);
      final Iterable<Horario> horarios = Iterables.<Horario>concat(_map);
      final Function1<Horario, Boolean> _function_1 = new Function1<Horario, Boolean>() {
        public Boolean apply(final Horario it) {
          Materia _materia = it.getMateria();
          return Boolean.valueOf(Objects.equal(_materia, m));
        }
      };
      Iterable<Horario> _filter = IterableExtensions.<Horario>filter(horarios, _function_1);
      final Function2<Integer, Horario, Integer> _function_2 = new Function2<Integer, Horario, Integer>() {
        public Integer apply(final Integer sum, final Horario h) {
          int _obtenerCantidadDeHorasDeMateria = MyDslValidator.this.obtenerCantidadDeHorasDeMateria(h);
          return Integer.valueOf(((sum).intValue() + _obtenerCantidadDeHorasDeMateria));
        }
      };
      _xblockexpression = IterableExtensions.<Horario, Integer>fold(_filter, Integer.valueOf(0), _function_2);
    }
    return _xblockexpression;
  }
  
  private int obtenerCantidadDeHorasDeMateria(final Horario h) {
    int _horarioFin = h.getHorarioFin();
    int _horarioInicio = h.getHorarioInicio();
    return (_horarioFin - _horarioInicio);
  }
  
  private boolean contieneAMateria(final Asignacion asignacion, final Materia m) {
    EList<Horario> _horarios = asignacion.getHorarios();
    final Function1<Horario, Boolean> _function = new Function1<Horario, Boolean>() {
      public Boolean apply(final Horario horario) {
        Materia _materia = horario.getMateria();
        return Boolean.valueOf(_materia.equals(m));
      }
    };
    return IterableExtensions.<Horario>exists(_horarios, _function);
  }
  
  @Check
  public void checkRecursosSatisfechos(final Horario horario) {
    Aula _aula = horario.getAula();
    final EList<Recursos> recursosAsignados = _aula.getRecursos();
    Materia _materia = horario.getMateria();
    final EList<Recursos> recursosMateria = _materia.getRecursos();
    boolean _containsAll = recursosAsignados.containsAll(recursosMateria);
    boolean _not = (!_containsAll);
    if (_not) {
      Aula _aula_1 = horario.getAula();
      String _name = _aula_1.getName();
      String _plus = ("El aula: " + _name);
      String _plus_1 = (_plus + " no tiene las recursos necesarios");
      this.error(_plus_1, horario, MyDslPackage.Literals.HORARIO__AULA);
    }
  }
  
  @Check
  public void checkInscriptosCabenEnAula(final Horario h) {
    EObject _eContainer = h.eContainer();
    EObject _eContainer_1 = _eContainer.eContainer();
    final Planificacion planificacion = ((Planificacion) _eContainer_1);
    EList<Curso> _cursos = planificacion.getCursos();
    Materia _materia = h.getMateria();
    Iterable<Curso> _obtenerCursoConMateria = this.obtenerCursoConMateria(_cursos, _materia);
    final Curso curso = ((Curso[])Conversions.unwrapArray(_obtenerCursoConMateria, Curso.class))[0];
    int _inscriptos = curso.getInscriptos();
    Aula _aula = h.getAula();
    int _capacidad = _aula.getCapacidad();
    boolean _greaterThan = (_inscriptos > _capacidad);
    if (_greaterThan) {
      Materia _materia_1 = h.getMateria();
      String _name = _materia_1.getName();
      String _plus = ("La cantidad de inscriptos de la materia: " + _name);
      String _plus_1 = (_plus + 
        " supera la capacidad del aula: ");
      Aula _aula_1 = h.getAula();
      String _name_1 = _aula_1.getName();
      String _plus_2 = (_plus_1 + _name_1);
      this.error(_plus_2, h, MyDslPackage.Literals.HORARIO__MATERIA);
    }
  }
  
  private Iterable<Curso> obtenerCursoConMateria(final EList<Curso> cursos, final Materia m) {
    final Function1<Curso, Boolean> _function = new Function1<Curso, Boolean>() {
      public Boolean apply(final Curso c) {
        Materia _materia = c.getMateria();
        return Boolean.valueOf(Objects.equal(_materia, m));
      }
    };
    return IterableExtensions.<Curso>filter(cursos, _function);
  }
  
  @Check
  public void checkSuperposicion(final Horario horario) {
    EObject _eContainer = horario.eContainer();
    final Asignacion asignacionQueContieneAHorario = ((Asignacion) _eContainer);
    EList<Horario> _horarios = asignacionQueContieneAHorario.getHorarios();
    final Function1<Horario, Boolean> _function = new Function1<Horario, Boolean>() {
      public Boolean apply(final Horario h) {
        boolean _equals = MyDslValidator.this.operator_equals(h, horario);
        return Boolean.valueOf((!_equals));
      }
    };
    final Iterable<Horario> horariosDelDia = IterableExtensions.<Horario>filter(_horarios, _function);
    final Procedure1<Horario> _function_1 = new Procedure1<Horario>() {
      public void apply(final Horario it) {
        MyDslValidator.this.colapsaCon(it, horario);
      }
    };
    IterableExtensions.<Horario>forEach(horariosDelDia, _function_1);
  }
  
  public void colapsaCon(final Horario h1, final Horario h2) {
    boolean _and = false;
    Aula _aula = h1.getAula();
    Aula _aula_1 = h2.getAula();
    boolean _equals = Objects.equal(_aula, _aula_1);
    if (!_equals) {
      _and = false;
    } else {
      boolean _or = false;
      int _horarioInicio = h1.getHorarioInicio();
      int _horarioInicio_1 = h2.getHorarioInicio();
      int _horarioFin = h2.getHorarioFin();
      boolean _estaEntre = this.estaEntre(Integer.valueOf(_horarioInicio), Integer.valueOf(_horarioInicio_1), Integer.valueOf(_horarioFin));
      if (_estaEntre) {
        _or = true;
      } else {
        int _horarioFin_1 = h1.getHorarioFin();
        int _horarioInicio_2 = h2.getHorarioInicio();
        int _horarioFin_2 = h2.getHorarioFin();
        boolean _estaEntre_1 = this.estaEntre(Integer.valueOf(_horarioFin_1), Integer.valueOf(_horarioInicio_2), Integer.valueOf(_horarioFin_2));
        _or = _estaEntre_1;
      }
      _and = _or;
    }
    if (_and) {
      Materia _materia = h1.getMateria();
      String _name = _materia.getName();
      String _plus = ("el horario de la materia: " + _name);
      String _plus_1 = (_plus + " colapsa con el horario de la materia: ");
      Materia _materia_1 = h2.getMateria();
      String _name_1 = _materia_1.getName();
      String _plus_2 = (_plus_1 + _name_1);
      this.error(_plus_2, h1, MyDslPackage.Literals.HORARIO__HORARIO_INICIO);
    }
  }
  
  private boolean estaEntre(final Integer i, final Integer i2, final Integer i3) {
    boolean _and = false;
    boolean _lessThan = (i2.compareTo(i) < 0);
    if (!_lessThan) {
      _and = false;
    } else {
      boolean _lessThan_1 = (i.compareTo(i3) < 0);
      _and = _lessThan_1;
    }
    return _and;
  }
  
  private boolean operator_equals(final Horario h1, final Horario h2) {
    boolean _and = false;
    boolean _and_1 = false;
    boolean _and_2 = false;
    Aula _aula = h1.getAula();
    Aula _aula_1 = h2.getAula();
    boolean _equals = Objects.equal(_aula, _aula_1);
    if (!_equals) {
      _and_2 = false;
    } else {
      int _horarioInicio = h1.getHorarioInicio();
      int _horarioInicio_1 = h2.getHorarioInicio();
      boolean _equals_1 = (_horarioInicio == _horarioInicio_1);
      _and_2 = _equals_1;
    }
    if (!_and_2) {
      _and_1 = false;
    } else {
      int _horarioFin = h1.getHorarioFin();
      int _horarioFin_1 = h2.getHorarioFin();
      boolean _equals_2 = (_horarioFin == _horarioFin_1);
      _and_1 = _equals_2;
    }
    if (!_and_1) {
      _and = false;
    } else {
      Materia _materia = h1.getMateria();
      Materia _materia_1 = h2.getMateria();
      boolean _equals_3 = Objects.equal(_materia, _materia_1);
      _and = _equals_3;
    }
    return _and;
  }
}
