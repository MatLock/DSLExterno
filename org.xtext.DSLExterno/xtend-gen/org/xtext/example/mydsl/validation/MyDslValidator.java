/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.mydsl.myDsl.Clase;
import org.xtext.example.mydsl.myDsl.Dedicacion;
import org.xtext.example.mydsl.myDsl.Materia;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Profesor;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  @Check
  public void checkDedicacion(final Materia m) {
    final Profesor profesor = m.getDictadaPor();
    EObject _eContainer = m.eContainer();
    final Model planificacion = ((Model) _eContainer);
    EList<Clase> _clases = planificacion.getClases();
    final Iterable<Materia> materias = Iterables.<Materia>filter(_clases, Materia.class);
    int _cantidadDeVeces = this.cantidadDeVeces(profesor, materias);
    int _cantidadDeMateriasPorDedicacion = this.cantidadDeMateriasPorDedicacion(profesor);
    boolean _greaterThan = (_cantidadDeVeces > _cantidadDeMateriasPorDedicacion);
    if (_greaterThan) {
      String _name = profesor.getName();
      String _plus = ("El Profesor: " + _name);
      String _plus_1 = (_plus + " tiene asignadas mas materias de las que puede dictar");
      this.error(_plus_1, m, MyDslPackage.Literals.MATERIA__DICTADA_POR);
    }
  }
  
  public int cantidadDeVeces(final Profesor profesor, final Iterable<Materia> list) {
    final Function1<Materia, Boolean> _function = new Function1<Materia, Boolean>() {
      public Boolean apply(final Materia materia) {
        Profesor _dictadaPor = materia.getDictadaPor();
        return Boolean.valueOf(_dictadaPor.equals(profesor));
      }
    };
    final Iterable<Materia> cant = IterableExtensions.<Materia>filter(list, _function);
    return IterableExtensions.size(cant);
  }
  
  public int cantidadDeMateriasPorDedicacion(final Profesor p) {
    Dedicacion _dedicacion = p.getDedicacion();
    if (_dedicacion != null) {
      switch (_dedicacion) {
        case SIMPLE:
          return 1;
        case SEMI:
          return 2;
        case EXCLUSIVA:
          return 5;
        default:
          String _name = p.getName();
          String _plus = ("El profesor: " + _name);
          String _plus_1 = (_plus + " no tiene una dedicacion asignada");
          throw new RuntimeException(_plus_1);
      }
    } else {
      String _name = p.getName();
      String _plus = ("El profesor: " + _name);
      String _plus_1 = (_plus + " no tiene una dedicacion asignada");
      throw new RuntimeException(_plus_1);
    }
  }
}
