/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation

import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.Asignacion
import org.xtext.example.mydsl.myDsl.Curso
import org.xtext.example.mydsl.myDsl.Horario
import org.xtext.example.mydsl.myDsl.Materia
import org.xtext.example.mydsl.myDsl.MyDslPackage
import org.xtext.example.mydsl.myDsl.Planificacion
import org.xtext.example.mydsl.myDsl.Profesor

import static org.xtext.example.mydsl.myDsl.Dedicacion.*
import org.xtext.example.mydsl.myDsl.Dia
import java.util.List
import org.xtext.example.mydsl.myDsl.DiasHabilitados

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
 
class MyDslValidator extends AbstractMyDslValidator {
    

// chequeo de dedicacion del profesor
	@Check
	def dedicacion(Planificacion p){
		val cursos = p.cursos
		cursos.forEach[c | c.checkDedicacion]
	}
	
	def checkDedicacion(Curso curso) {
		val profesor = curso.dictadaPor
		val planificacion = curso.eContainer as Planificacion
		val cursos = planificacion.cursos 
		if(profesor.cantidadDeVeces(cursos) > profesor.cantidadDeMateriasPorDedicacion){
			error("El Profesor: " +profesor.name+" tiene asignadas mas materias de las que puede dictar"
			,profesor,MyDslPackage.Literals.PROFESOR__DEDICACION)
		}
	}
	
	private def cantidadDeVeces(Profesor profesor, Iterable<Curso> cursos) {
		 cursos.filter([dictadaPor.equals(profesor)]).size
	}
	
	private def cantidadDeMateriasPorDedicacion(Profesor p){
		switch p.dedicacion{
			case SIMPLE: return 1
			case SEMI: return 2
			case EXCLUSIVA: return 5
			default:
				 throw new RuntimeException("El profesor: "+ p.name+ " no tiene una dedicacion asignada")
		}
	}
	
 //chequeo de materias asignadas
	@Check
	def checkMateriasAsignadas(Planificacion p){
		val materias = p.cursos.materias
		val asignaciones = p.asignaciones
		val expresionBooleana = materias.forall[materia | materia.perteneceAAlgunaAsignacion(asignaciones)]
		if(! expresionBooleana){
			error("Hay materias sin asignar",p,MyDslPackage.Literals.PLANIFICACION__CURSOS)
		}
	}
	
	private	def materias(EList<Curso> cursos) {
		cursos.map[materia]
	}
	
	private def  perteneceAAlgunaAsignacion(Materia materia, EList<Asignacion> asignaciones){
		 asignaciones.exists[tieneMateria(materia)]
	}
	
	private def tieneMateria(Asignacion a, Materia materia) {
		a.horarios.exists[h | h.materia == materia]
	}
	
// chequeo de carga horaria de materia con dias asignados
	@Check
	def checkCargaHorariaDeMateria(Planificacion p){
		val materias = p.cursos.materias
		materias.forEach[materia | materia.chequearHorarios(p)]		
	}
	
// NOTA: paso por parametro la planificacion para poder marcar el error en la planificacion!!!
	private def void chequearHorarios(Materia materia, Planificacion p){
		
		val asignacionesDeMateria = materia.asignaciones(p)
		var cargaHorariaDeMateria =  asignacionesDeMateria.obtenerCargaDeMateria(materia)
		var cantidadDeDiasDeMateria = asignacionesDeMateria.size
		
		if ( !( (cargaHorariaDeMateria == materia.cargaHoraria) && 
					(cantidadDeDiasDeMateria == materia.cantidadDeDias))){
			error("La materia: "+materia.name+" No cumple con la carga horaria o con la cantidad De Dias ",
				p,MyDslPackage.Literals.PLANIFICACION__ANIO
			)
		}
	}
	
	private def asignaciones(Materia m, Planificacion p){
		p.asignaciones.filter[asignacion | asignacion.contieneAMateria(m)]
	}
	
	private def obtenerCargaDeMateria(Iterable<Asignacion> asignaciones, Materia m){
		val horarios = asignaciones.map[horarios].flatten // concat [[a]] -> [a]
		horarios.filter([materia == m]).fold(0)[sum, h | sum + h.obtenerCantidadDeHorasDeMateria ]
		//foldr ( \ a result -> a + result) 0 (sum es result "esta al reves))(para listas) 
	}
	
	private def obtenerCantidadDeHorasDeMateria(Horario h){
		return  h.horarioFin - h.horarioInicio 
	}
	
	private def  boolean contieneAMateria(Asignacion asignacion, Materia m){
		return asignacion.horarios.exists[horario | horario.materia.equals(m)]
	}
	
	
	
// chequeo de compatibilidad de aula y materia
	@Check
	def checkRecursosSatisfechos(Horario horario){
		val recursosAsignados = horario.aula.recursos
		val recursosMateria = horario.materia.recursos

		if(!recursosAsignados.containsAll(recursosMateria)){
			error("El aula: " +horario.aula.name+" no tiene las recursos necesarios"
			,horario,MyDslPackage.Literals.HORARIO__AULA)
		}
	}
		
	// Check super posicion de aulas con horarios
	@Check
	def checkSuperposicion(Horario horario){
		val asignacionQueContieneAHorario = horario.eContainer as Asignacion
		val horariosDelDia = asignacionQueContieneAHorario.horarios.filter[h| !(h==horario)]
		horariosDelDia.forEach[colapsaCon(horario)]
	}
	
	def colapsaCon(Horario h1 ,Horario h2) {
		if (h1.aula == h2.aula && (h1.horarioInicio.estaEntre(h2.horarioInicio,h2.horarioFin) ||
			h1.horarioFin.estaEntre(h2.horarioInicio,h2.horarioFin))){
				error("el horario de la materia: " +h1.materia.name +" colapsa con el horario de la materia: "
					+h2.materia.name,h1,MyDslPackage.Literals.HORARIO__HORARIO_INICIO)
			}
	}
	
	private def estaEntre(Integer i , Integer i2, Integer i3){
		return i2 <= i  && i <= i3
	}
	
	private def operator_equals(Horario h1 , Horario h2){
		return h1.aula == h2.aula && h1.horarioInicio == h2.horarioInicio && 
			   h1.horarioFin == h2.horarioFin && h1.materia == h2.materia	
	}
	
	//Check del primer Bonus (inscritos caben en aula)	
	@Check
	def checkInscriptosCabenEnAula(Horario h){
		val planificacion = (h.eContainer.eContainer) as Planificacion
		val curso = planificacion.cursos.obtenerCursoConMateria(h.materia).get(0)
		if (curso.inscriptos > h.aula.capacidad){
			error("La cantidad de inscriptos de la materia: "+h.materia.name+
			" supera la capacidad del aula: "+h.aula.name,h,MyDslPackage.Literals.HORARIO__MATERIA)
		}
	}
	
	private def obtenerCursoConMateria(EList<Curso> cursos ,Materia m){
		cursos.filter[c | c.materia == m ]
	}
	
	// Check del segundo Bonus ( Restricciones horarias para los profesores //
	@Check
	def checkRestriccionHoraria(Planificacion p){
		val cursos = p.cursos
		cursos.forEach[c | c.buscarRestriccion(p)]
		
	}
	
	def  buscarRestriccion(Curso curso, Planificacion p){
		 val asignacionesConMateria = curso.materia.asignaciones(p)
		 asignacionesConMateria.forEach[a | a.verificarCondicionHoraria(curso) ]
	}
	
	// asignacion que posee la o las materias que dicta el profesor en ese dia   
	def verificarCondicionHoraria(Asignacion asignacion, Curso curso){
		val profesor = curso.dictadaPor
		val diasQuePuedeElProfesor = profesor.diasQuePuede.map[dq | dq.dia]
		
		if(asignacion.dia.estaEntreLosDias(diasQuePuedeElProfesor)){
			asignacion.verificarHorario(curso)
		}else{
			error("el profesor: "+ profesor.name+" no puede dictar clases el dia: "+asignacion.dia
				,asignacion,MyDslPackage.Literals.ASIGNACION__DIA)
		}
	}
	
	def verificarHorario(Asignacion a,Curso curso){
		val profesor = curso.dictadaPor
		val materiaDeCurso = curso.materia
		val horarioHabilitadoParaDia = profesor.diasQuePuede.filter([dq | dq.dia == a.dia]).get(0)
		val horariosDeMateria = a.horarios.filter[h | h.materia == materiaDeCurso]
		if(horariosDeMateria.algunHorarioNoCumple(horarioHabilitadoParaDia)){
			error("el profesor: "+profesor.name+" no puede dictar clases en algun horario"
				,a,MyDslPackage.Literals.ASIGNACION__DIA
			)
		}
	}
	
	def boolean algunHorarioNoCumple(Iterable<Horario> horarios, DiasHabilitados d){
		! horarios.forall[h | ( h.horarioInicio.estaEntre(d.horaInicio,d.horaFinal)
									&&   h.horarioFin <= d.horaFinal )	
					    ]
	}
	
	def estaEntreLosDias(Dia dia, List<Dia> dias) {
		dias.exists[d | d == dia ] 
	}
	
}

