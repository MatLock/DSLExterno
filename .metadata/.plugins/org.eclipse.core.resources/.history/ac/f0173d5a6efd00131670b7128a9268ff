/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation

import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.Materia
import org.xtext.example.mydsl.myDsl.Model
import org.xtext.example.mydsl.myDsl.MyDslPackage
import org.xtext.example.mydsl.myDsl.Profesor

import static org.xtext.example.mydsl.myDsl.Dedicacion.*
import org.xtext.example.mydsl.myDsl.Planificacion
import org.xtext.example.mydsl.myDsl.Asignacion
import org.eclipse.emf.common.util.EList

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
 
class MyDslValidator extends AbstractMyDslValidator {

	@Check
	def checkDedicacion(Materia m) {
		val profesor = m.dictadaPor
		val planificacion = m.eContainer as Model
		val materias = planificacion.clases.filter(Materia)
		if(cantidadDeVeces(profesor,materias) > profesor.cantidadDeMateriasPorDedicacion){
			error("El Profesor: " +profesor.name+" tiene asignadas mas materias de las que puede dictar"
			,m,MyDslPackage.Literals.MATERIA__DICTADA_POR)
		}
	}
	
	def cantidadDeVeces(Profesor profesor, Iterable<Materia> list) {
		val cant = list.filter [materia | materia.dictadaPor.equals(profesor)]
		return cant.size
	}
	
	def cantidadDeMateriasPorDedicacion(Profesor p){
		switch p.dedicacion{
			case SIMPLE: return 1
			case SEMI: return 2
			case EXCLUSIVA: return 5
			default:
				 throw new RuntimeException("El profesor: "+ p.name+ " no tiene una dedicacion asignada")
		}
	}
	
	@Check
	def checkMateriasAsignadas(Planificacion p){
		val materias = p.materias
		val asignaciones = p.asignaciones
		val expresionBooleana = asignaciones.[asignacion | asignacion.contieneAlgunamateria(materias)]
		if()
	}
	
	
	def contieneAlgunaMateria(Asignacion a,EList<Materia>materias){
	 	var materiasDeAsignacion = materias.map[materia | materia.equals(a.materia)]
	 	return materiasDeAsignacion.exists[bool | bool == true]
	}
	
}

